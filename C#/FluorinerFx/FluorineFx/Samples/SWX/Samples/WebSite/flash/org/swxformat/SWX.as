/** * * SWX ActionScript API  * Copyright © 2007 Aral Balkan. http://aralbalkan.com * Part of the SWX (SWF Data Exchange Format) project. http://swxformat.org * * Released under the open source MIT license. * http://opensource.org/licenses/mit-license.php * */import org.swxformat.*; import mx.utils.Delegate; class org.swxformat.SWX{	// Constants	public static var POST:String = "POST";	public static var GET:String = "GET";		// Should the class give verbose error and info messages?	public static var verbose:Boolean = true;		// Static vars	private static var json:String = '';		// Private instance vars	private var _gateway:String = null; 	private var _testGateway:String = null;	private var _encoding:String = SWX.POST;	private var _resultObj:Object = null;	private var _resultFn:Function = null;	private var _progressObj:Object = null;	private var _progressFn:Function = null;	private var _debug:Boolean = false;	private var _timeout:Number = 30; // seconds	//	// Instance methods	//		public function SWX()	{		if (!SWX.verbose) 		{			// Don't display status or error messages.			SWX.echo = null;						// And make sure the classes we use do the same.			ExternalAsset.verbose = false;			LoadManager.verbose = false;		}	}			// The test gateway is used when your Flash movie	// is run from the standalone player or from the Flash IDE.	// TODO: Is this being used? Doesn't look like it.	public function set testGateway (gatewayUrl:String)	{		_testGateway = gatewayUrl;	}	public function set gateway (gatewayUrl:String)	{		_gateway = gatewayUrl;				// Allow SWFs loaded from the gateway to access the 		// movie. This is only required at the moment 		// for _parent._url to work in the loaded SWF so that 		// (if allowDomain is on on the server) the loading 		// SWF can read the data SWF. 		//		// TODO: Will it work if we actually write the URL of 		// the loading SWF (referer) into the allowDomain call		// on the data SWF instead of using _parent._url? This should		// mean that we can remove this call and this should		// make SWX more secure as it will not allow malicious		// SWFs created via third-party SWX gateways any access		// into the parent SWF. 		//System.security.allowDomain(_gateway);	}	// Set the HTTP encoding type	public function set encoding (method:String)	{		if (method != SWX.POST && method != SWX.GET)		{			// Not using throw to make SWX AS Flash 6 compatible (for PSP, etc.)			//throw (new Error("SWX: Invalid encoding method ("+method+"). Valid methods are POST and GET."));						echo ("SWX ERROR: Invalid encoding method ("+method+"). Valid methods are POST and GET.");		}		else		{			_encoding = method;		}	}		public function set debug (state:Boolean)	{		_debug = state;	}		// Set the timeout (in seconds)	public function set timeout (duration:Number)	{		if (duration > 0)		{			_timeout = duration;		}	}		// Set global result handler	public function set result (resultHandler:Object)	{		_resultObj = resultHandler.obj;		_resultFn = resultHandler.fn;	}		// Set global progress handler	public function set progress (progressHandler:Object)	{		_progressObj = progressHandler.obj;		_progressFn = progressHandler.fn;	}	// Call remote method	public function call (p:Object)	{		var validArguments:Object =		{serviceClass:true, method:true, args:true, result:true, progress:true, timeout:true, fault:true, debug:true};		// Check validitity of parameter object properties.		if (echo != null)		{			var warnings:Boolean = false;			for (var key:String in p)			{				if (validArguments[key] !== true)				{					echo ("Warning: Unknown argument in SWX.call. " + key + " is not a valid argument.");					warnings = true;				}			}			if (warnings) 			{				var validArgumentsStr:String = ""				for (var key:String in validArguments)				{					validArgumentsStr += key + ", ";				}				validArgumentsStr = validArgumentsStr.substr(0, validArgumentsStr.length - 2);				echo ("Valid arguments for SWX.call are: " + validArgumentsStr);			}		}				var debug:Boolean = (p.debug == undefined) ? _debug : p.debug;		var args:Object = {serviceClass:p.serviceClass, method:p.method, args:p.args};		if (debug != undefined)		{			args.debug = debug;		}				// Add the URL of the calling SWF so that it can be used in the 		// allowDomain call in the returned SWX SWF.		// trace("Adding url: " + _url);				// Using this here so that MTASC does not choke on it. 		args.url = _root._url;						// Create the external asset		var externalAsset:ExternalAsset = new ExternalAsset(null, _gateway, args, _encoding);				// Set the timeout duration.		externalAsset.setTimeout(_timeout);				// Listen for the load event if a result handler has been defined.		if (p.result != undefined)		{			if (typeof p.result[1] != "function") 			{				echo ("SWX.call ERROR: Result handler should be in the form [resultObject, resultFunction] (found "+typeof p.result[1]+" for resultFunction instead of a function reference.");			}			else			{				externalAsset.addEventListener(ExternalAsset.LOAD, Delegate.create(p.result[0], p.result[1]));			}		}		else		{			echo ("SWX.call INFO: No result handler defined.");		}				// Listen for the progress event if a progress handler has been defined.		if (p.progress != undefined)		{			if (typeof p.progress[1] != "function") 			{				echo ("SWX.call ERROR: Progress handler should be in the form [progressObject, progressFunction] (found "+typeof p.progress[1]+" for progressFunction instead of a function reference.");			}			else			{				externalAsset.addEventListener(ExternalAsset.PROGRESS, Delegate.create(p.progress[0], p.progress[1]));			}		}		else		{			echo ("SWX.call INFO: No progress handler defined.");		}				// Listen for the timeout event if a timeout handler has been defined.		if (p.timeout != undefined)		{			if (typeof p.result[1] != "function") 			{				echo ("SWX.call ERROR: Timeout handler should be in the form [timeoutObject, timeoutFunction] (found "+typeof p.timeout[1]+" for timeoutFunction instead of a function reference.");			}			else			{				externalAsset.addEventListener(ExternalAsset.TIMEOUT, Delegate.create(p.timeout[0], p.timeout[1]));			}		}		else		{			echo ("SWX.call INFO: No timeout handler defined.");		}				// Listen for the fault event if a fault handler has been defined.		if (p.fault != undefined)		{			if (typeof p.fault[1] != "function") 			{				echo ("SWX.call ERROR: Fault handler should be in the form [faultObject, faultFunction] (found "+typeof p.fault[1]+" for faultFunction instead of a function reference.");			}			else			{				externalAsset.addEventListener(ExternalAsset.FAULT, Delegate.create(p.fault[0], p.fault[1]));			}		}		else		{			echo ("SWX.call INFO: No fault handler defined.");		}		// Add the load request to the main load queue.		var loadManager:LoadManager = LoadManager.getInstance();		loadManager.load(externalAsset);							}		public function cancelAllCalls()	{		LoadManager.getInstance().cancelAllLoads();	}		// Traces the passed string. (Gets nulled out in non-verbose mode.)	static private function echo(msg:String)	{		trace (msg);	}		/**     * Converts the arguments array (if any) to JSON     *	 * Usage: 	 *		import org.swxformat.*;	 * 		Swx.prepare(dataHolder);     */	 	static function prepare(dataHolder:MovieClip):Void	{		// Display a status message so that users are alerted if they		// forget to import the class. 		echo("SWX.prepare: " + dataHolder);				json = "";				if (dataHolder.args != undefined)		{			if (dataHolder.args instanceof Array)			{				arrayToJson(dataHolder.args);				dataHolder.args = json;			}			else			{				echo ("SWX Error in Swx.prepare(): args must be an array.");			}					}		else		{			echo ("SWX: No arguments array (args) found. No arguments will be sent.");		}	}		// Converts an object to JSON	static function objectToJson(data:Object)	{		json += "{";		for (var i:String in data)		{			json += '"' + i + '":';						var x = data[i];						// Note: check for Array first since everything is an Object.			if (x instanceof Array)			{				arrayToJson(x);			}			else if (x instanceof Object)			{				objectToJson(x);			}			else if (typeof x == "string")			{				stringToJson(x);			}			else			{				// Other simple data type, add as-is				json += x;							}			json += ", ";		}		json = json.substr(0, json.length-2);		json += "}";	}		// Converts an array to JSON	static function arrayToJson(data:Array)	{		json += "[";		var len:Number = data.length;				for (var i = 0; i < len; i++)		{			var x = data[i];			// Note: check for Array first since everything is an Object.			if (x instanceof Array)			{				arrayToJson(x);			}			else if (x instanceof Object)			{				objectToJson(x);			}			else if (typeof x == "string")			{				stringToJson(x);			}			else			{				// Other simple data type, add as-is				json += x;							}			json += ", ";		}		json = json.substr(0, json.length-2);		json += "]";	}		static function stringToJson(data:String)	{ 		// From JSON.as by Trannie Carter <tranniec@designvox.com>		// http://json.org/json.as		var l:Number = data.length;		json += '"';		for (var i:Number = 0; i < l; i += 1) 		{			var c = data.charAt(i);			if (c >= ' ') 			{				if (c == '\\' || c == '"' || c == "'") 				{					json += '\\';				}				json += c;			} 			else 			{				switch (c) 				{										case '\b':						json += '\\b';						break;					case '\f':						json += '\\f';						break;					case '\n':						json += '\\n';						break;					case '\r':						json += '\\r';						break;					case '\t':						json += '\\t';						break;										/*					case '\b':					case '\f':					case '\n':					case '\r':					case '\t':					json += '\\' + c;					break;											*/					default:						c = c.charCodeAt();						json += '\\u00' + Math.floor(c / 16).toString(16) +						    (c % 16).toString(16);				}			}		}				json += '"';	}			}